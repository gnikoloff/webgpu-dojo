!function(){"use strict";function t(t,a,n,u){return new(n=n||Promise)(function(r,e){function i(t){try{o(u.next(t))}catch(t){e(t)}}function s(t){try{o(u.throw(t))}catch(t){e(t)}}function o(t){var e;t.done?r(t.value):((e=t.value)instanceof n?e:new n(function(t){t(e)})).then(i,s)}o((u=u.apply(t,a||[])).next())})}class e{constructor(t){this.device=t}get(){return this.buffer}destroy(){this.buffer.destroy()}}class s extends e{constructor(t,e){super(t),this.itemsCount=e.length,this.typedArray=e,this.buffer=t.createBuffer({size:8*Math.ceil(e.byteLength/8),usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new(this.typedArray instanceof Uint16Array?Uint16Array:Uint32Array)(this.buffer.getMappedRange()).set(e),this.buffer.unmap()}get isInt16(){return this.typedArray instanceof Uint16Array}bind(t){return t.setIndexBuffer(this.buffer,this.isInt16?"uint16":"uint32"),this}}class o{constructor(t=0,e=3,r="float32x4"){this.offset=0,this.size=3,this.format="float32x4",this.offset=t,this.size=e,this.format=r}}class h extends e{constructor(t,e,r,i=4*Float32Array.BYTES_PER_ELEMENT,s=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,o="vertex"){super(t),this.attributes=new Map,this.stepMode="vertex",this.bindPointIdx=e,this.typedArray=r,this.arrayStride=i,this.stepMode=o,this.buffer=t.createBuffer({size:r.byteLength,usage:s,mappedAtCreation:!0}),new Float32Array(this.buffer.getMappedRange()).set(r),this.buffer.unmap()}get itemsCount(){return this.typedArray.length/this.arrayStride}getLayout(r){return this.attributes.size,{arrayStride:this.arrayStride,stepMode:this.stepMode,attributes:Array.from(this.attributes).map(([,t],e)=>({offset:t.offset,format:t.format,shaderLocation:r+e}))}}addAttribute(t,e=0,r=3,i="float32x4"){i=new o(e,r,i);return this.attributes.set(t,i),this}bind(t){return t.setVertexBuffer(this.bindPointIdx,this.buffer),this}}class r extends e{constructor(t,e,r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST){super(t),this.byteLength=e,this.buffer=t.createBuffer({size:e,usage:r})}write(t,e){return this.device.queue.writeBuffer(this.buffer,t,e),this}}class v{constructor(t){this.source="",this.device=t}static getVertexInputFormat(t){switch(t){case"float32":return"f32";case"float32x2":return"vec2<f32>";case"float32x3":case"float32x4":return"vec4<f32>"}}get shaderModule(){return this.module||(this.module=this.device.createShaderModule({code:this.source})),this.module}addUniformInputs(t,e=1){return this.source+=`
      [[block]] struct UniformsInput {
        ${Object.entries(t).reduce((t,[e,{type:r}])=>t+=`${e}: ${r};`,"")}
      };

      [[group(0), binding(${e})]] var<uniform> inputUBO: UniformsInput;
    `,this}addTextureInputs(t){return this.source+=t.reduce((t,{bindIdx:e,name:r,type:i})=>t+`
          [[group(0), binding(${e})]] var ${r}: ${i};
        `,""),this}addSamplerInputs(t){return this.source+=t.reduce((t,{bindIdx:e,name:r,type:i})=>t+`
          [[group(0), binding(${e})]] var ${r}: ${i};
          `,""),this}addStorages(t){return t.forEach(({bindIdx:t,name:e,attributes:r})=>{this.source+=`
        struct ${e} {
          ${Object.entries(r).map(([t,e])=>`${t}: ${e};`).join("\n")}
        };

        [[block]] struct ${e}Collection {
          ${e.toLowerCase()}s: [[stride(48)]] array<Light>;
        };

        [[group(0), binding(${t})]] var<storage, read_write> ${e.toLowerCase()}Collection: ${e}Collection;
      `}),this}addHeadSnippet(t){return t&&(this.source+=t),this}}v.ENTRY_FUNCTION="main";class M extends v{constructor(t){super(t),this.source+=M.TRANSFORM_UBO_SNIPPET}addShaderVars(t,e={}){let i=0,s="",o="";t.forEach(({attributes:t})=>{for(var[e,{format:r}]of t){r=v.getVertexInputFormat(r);s+=`
          [[location(${i})]] ${e}: ${r};
        `,o+=`
          [[location(${i})]] ${e}: ${r};
        `,i++}});for(var[r,{format:a}]of Object.entries(e)){a=v.getVertexInputFormat(a);o+=`
        [[location(${i})]] ${r}: ${a};
      `,i++}return this.source+=`
      struct Input {
        ${s}
      };

      struct Output {
        [[builtin(position)]] Position: vec4<f32>;
        ${o}
      };
    `,this}addMainFnSnippet(t){return this.source+=`
      [[stage(vertex)]] fn main (input: Input) -> Output {
        var output: Output;
        ${t}
        return output;
      }
    `,this}}M.TRANSFORM_UBO_SNIPPET=`
    [[block]] struct Transform {
      projectionMatrix: mat4x4<f32>;
      viewMatrix: mat4x4<f32>;
      modelMatrix: mat4x4<f32>;
      normalMatrix: mat4x4<f32>;
    };

    [[group(0), binding(0)]] var<uniform> transform: Transform;
  `;class T extends v{addShaderVars(t,e={},r={}){let i=0,s=0,o="",a="";t.forEach(({attributes:t})=>{for(var[e,{format:r}]of t){r=v.getVertexInputFormat(r);o+=`
          [[location(${i})]] ${e}: ${r};
        `,i++}});for(var[n,{format:u}]of Object.entries(e)){u=v.getVertexInputFormat(u);o+=`
        [[location(${i})]] ${n}: ${u};
      `,i++}for(var[h,{format:d}]of Object.entries(r)){d=v.getVertexInputFormat(d);a+=`
        [[location(${s+1})]] ${h}: ${d};
      `,s++}return this.source+=`
      struct Input {
        [[builtin(position)]] coords: vec4<f32>;
        ${o}
      };

      struct Output {
        [[location(0)]] Color: vec4<f32>;
        ${a}
      };
    `,this}addMainFnSnippet(t){return this.source+=`
      [[stage(fragment)]] fn main (input: Input) -> Output {
        var output: Output;
        ${t}
        return output;
      }
    `,this}}class B{constructor(t,e=0){this.samplers=[],this.textures=[],this.uniformBlocks=[],this.storageBuffers=[],this.device=t,this.bindingIndex=e}bind(t){return t.setBindGroup(this.bindingIndex,this.bindGroup),this}addSampler(t){return this.samplers.push(t),this}addTexture(t){return this.textures.push(t),this}addStorage(t){return this.storageBuffers.push(t),this}addUBO(t){t=new r(this.device,t);return this.uniformBlocks.push(t),this}writeToUBO(t,e,r){const i=this.uniformBlocks[t];return i&&i.write(e,r),this}getLayout(){const e=[];let r=0;return this.uniformBlocks.forEach(()=>{e.push({visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,binding:r,buffer:{type:"uniform"}}),r++}),this.samplers.forEach(t=>{e.push({visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,binding:r,sampler:{type:t.bindingType}}),r++}),this.textures.forEach(t=>{e.push({visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,binding:r,texture:{sampleType:t.sampleType}}),r++}),this.storageBuffers.forEach(()=>{e.push({visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,binding:r,buffer:{type:"storage"}}),r++}),this.device.createBindGroupLayout({entries:e})}attachToPipeline(t){const r=[];let i=0;return this.uniformBlocks.forEach(t=>{r.push({binding:i,resource:{buffer:t.get(),offset:0,size:t.byteLength}}),i++}),this.samplers.forEach(t=>{r.push({binding:i,resource:t.get()}),i++}),this.textures.forEach((t,e)=>{r.push({binding:i,resource:t.get().createView()}),i++}),this.storageBuffers.forEach((t,e)=>{r.push({binding:i,resource:{buffer:t.get(),offset:0,size:t.byteLength}}),i++}),this.bindGroup=this.device.createBindGroup({layout:t.getBindGroupLayout(this.bindingIndex),entries:r}),this}destroy(){this.uniformBlocks.forEach(t=>t.destroy()),this.textures.forEach(t=>t.destroy()),this.samplers.forEach(t=>t.destroy()),this.storageBuffers.forEach(t=>t.destroy())}}const S="triangle-list",w=new Map([["mat4x4<f32>",[16,Float32Array.BYTES_PER_ELEMENT]],["mat3x3<f32>",[12,Float32Array.BYTES_PER_ELEMENT]],["vec4<f32>",[4,Float32Array.BYTES_PER_ELEMENT]],["vec3<f32>",[3,Float32Array.BYTES_PER_ELEMENT]],["vec2<f32>",[2,Float32Array.BYTES_PER_ELEMENT]],["f32",[1,Float32Array.BYTES_PER_ELEMENT]],["i32",[4,Int32Array.BYTES_PER_ELEMENT]],["u32",[4,Uint32Array.BYTES_PER_ELEMENT]],["i16",[1,Int16Array.BYTES_PER_ELEMENT]],["u16",[1,Uint16Array.BYTES_PER_ELEMENT]]]);class d{constructor(t){this.vertexCount=0,this.instanceCount=1,this.vertexBuffers=[],this.primitiveType=S,this.device=t}get hasIndex(){return!!this.indexBuffer}get stripIndexFormat(){var t;let e=void 0;return"line-strip"!==this.primitiveType&&"triangle-strip"!==this.primitiveType||(e=null!==(t=this.indexBuffer)&&void 0!==t&&t.isInt16?"uint16":"uint32"),e}addIndexBuffer(t){return this.vertexCount=t.itemsCount,this.indexBuffer=t,this}addVertexBuffer(t){return t.attributes.get("position")&&!this.vertexCount&&(this.vertexCount=t.itemsCount),this.vertexBuffers.push(t),this}getVertexBuffersLayout(){const t=[];let e=0;for(const r of this.vertexBuffers.values())t.push(r.getLayout(e)),e+=r.attributes.size;return t}draw(e){this.vertexBuffers.forEach(t=>t.bind(e)),this.indexBuffer?(this.indexBuffer.bind(e),e.drawIndexed(this.vertexCount,this.instanceCount)):e.draw(this.vertexCount,this.instanceCount)}destroy(){var t;null!==(t=this.indexBuffer)&&void 0!==t&&t.destroy(),this.vertexBuffers.forEach(t=>t.destroy())}}var c=1e-6,a="undefined"!=typeof Float32Array?Float32Array:Array;function n(){var t=new a(16);return a!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function I(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function g(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});var i,u,_=function(t,e,r){var i=e[0],s=e[1],o=e[2],a=e[3],n=e[4],u=e[5],h=e[6],d=e[7],p=e[8],f=e[9],l=e[10],c=e[11],m=e[12],x=e[13],g=e[14],y=e[15],E=r[0],b=r[1],v=r[2],e=r[3];return t[0]=E*i+b*n+v*p+e*m,t[1]=E*s+b*u+v*f+e*x,t[2]=E*o+b*h+v*l+e*g,t[3]=E*a+b*d+v*c+e*y,E=r[4],b=r[5],v=r[6],e=r[7],t[4]=E*i+b*n+v*p+e*m,t[5]=E*s+b*u+v*f+e*x,t[6]=E*o+b*h+v*l+e*g,t[7]=E*a+b*d+v*c+e*y,E=r[8],b=r[9],v=r[10],e=r[11],t[8]=E*i+b*n+v*p+e*m,t[9]=E*s+b*u+v*f+e*x,t[10]=E*o+b*h+v*l+e*g,t[11]=E*a+b*d+v*c+e*y,E=r[12],b=r[13],v=r[14],e=r[15],t[12]=E*i+b*n+v*p+e*m,t[13]=E*s+b*u+v*f+e*x,t[14]=E*o+b*h+v*l+e*g,t[15]=E*a+b*d+v*c+e*y,t};function p(t,e,r){var i=new a(3);return i[0]=t,i[1]=e,i[2]=r,i}function f(t,e,r,i){return t[0]=e,t[1]=r,t[2]=i,t}i=new a(3),a!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),u=new a(2),a!=Float32Array&&(u[0]=0,u[1]=0);class l{constructor(){this.position=p(0,0,0),this.rotation=p(0,0,0),this.scale=p(1,1,1),this.modelMatrix=n(),this.shouldUpdate=!0}copyFromMatrix(t){return I(this.modelMatrix,t),this.shouldUpdate=!1,this}setPosition(t){var{x:e=this.position[0],y:r=this.position[1],z:t=this.position[2]}=t;return f(this.position,e,r,t),this.shouldUpdate=!0,this}setScale(t){var{x:e=this.scale[0],y:r=this.scale[1],z:t=this.scale[2]}=t;return f(this.scale,e,r,t),this.shouldUpdate=!0,this}setRotation(t){var{x:e=this.rotation[0],y:r=this.rotation[1],z:t=this.rotation[2]}=t;return f(this.rotation,e,r,t),this.shouldUpdate=!0,this}updateModelMatrix(){var t,e,r,i,s,o,a,n,u,h,d,p,f,l,c,m,x;return g(this.modelMatrix),l=this.modelMatrix,o=this.modelMatrix,f=this.position,p=f[0],c=f[1],h=f[2],o===l?(l[12]=o[0]*p+o[4]*c+o[8]*h+o[12],l[13]=o[1]*p+o[5]*c+o[9]*h+o[13],l[14]=o[2]*p+o[6]*c+o[10]*h+o[14],l[15]=o[3]*p+o[7]*c+o[11]*h+o[15]):(t=o[0],e=o[1],u=o[2],d=o[3],r=o[4],i=o[5],m=o[6],x=o[7],s=o[8],a=o[9],n=o[10],f=o[11],l[0]=t,l[1]=e,l[2]=u,l[3]=d,l[4]=r,l[5]=i,l[6]=m,l[7]=x,l[8]=s,l[9]=a,l[10]=n,l[11]=f,l[12]=t*p+r*c+s*h+o[12],l[13]=e*p+i*c+a*h+o[13],l[14]=u*p+m*c+n*h+o[14],l[15]=d*p+x*c+f*h+o[15]),a=this.modelMatrix,u=this.modelMatrix,m=this.rotation[0],n=Math.sin(m),l=Math.cos(m),d=u[4],p=u[5],x=u[6],c=u[7],f=u[8],h=u[9],o=u[10],m=u[11],u!==a&&(a[0]=u[0],a[1]=u[1],a[2]=u[2],a[3]=u[3],a[12]=u[12],a[13]=u[13],a[14]=u[14],a[15]=u[15]),a[4]=d*l+f*n,a[5]=p*l+h*n,a[6]=x*l+o*n,a[7]=c*l+m*n,a[8]=f*l-d*n,a[9]=h*l-p*n,a[10]=o*l-x*n,a[11]=m*l-c*n,u=this.modelMatrix,f=this.modelMatrix,d=this.rotation[1],h=Math.sin(d),p=Math.cos(d),o=f[0],x=f[1],a=f[2],m=f[3],l=f[8],c=f[9],n=f[10],d=f[11],f!==u&&(u[4]=f[4],u[5]=f[5],u[6]=f[6],u[7]=f[7],u[12]=f[12],u[13]=f[13],u[14]=f[14],u[15]=f[15]),u[0]=o*p-l*h,u[1]=x*p-c*h,u[2]=a*p-n*h,u[3]=m*p-d*h,u[8]=o*h+l*p,u[9]=x*h+c*p,u[10]=a*h+n*p,u[11]=m*h+d*p,f=this.modelMatrix,o=this.modelMatrix,l=this.rotation[2],x=Math.sin(l),c=Math.cos(l),a=o[0],n=o[1],u=o[2],m=o[3],h=o[4],d=o[5],p=o[6],l=o[7],o!==f&&(f[8]=o[8],f[9]=o[9],f[10]=o[10],f[11]=o[11],f[12]=o[12],f[13]=o[13],f[14]=o[14],f[15]=o[15]),f[0]=a*c+h*x,f[1]=n*c+d*x,f[2]=u*c+p*x,f[3]=m*c+l*x,f[4]=h*c-a*x,f[5]=d*c-n*x,f[6]=p*c-u*x,f[7]=l*c-m*x,f=this.modelMatrix,l=this.modelMatrix,c=this.scale,m=c[0],x=c[1],c=c[2],f[0]=l[0]*m,f[1]=l[1]*m,f[2]=l[2]*m,f[3]=l[3]*m,f[4]=l[4]*x,f[5]=l[5]*x,f[6]=l[6]*x,f[7]=l[7]*x,f[8]=l[8]*c,f[9]=l[9]*c,f[10]=l[10]*c,f[11]=l[11]*c,f[12]=l[12],f[13]=l[13],f[14]=l[14],f[15]=l[15],this.shouldUpdate=!1,this}}class m extends l{constructor(){super(...arguments),this.renderable=!1,this.parentNode=null,this.children=[],this.worldMatrix=n(),this.normalMatrix=n(),this.setParent=(t=null)=>{var e;return!this.parentNode||0<=(e=this.parentNode.children.indexOf(this))&&this.parentNode.children.splice(e,1),t&&t.children.push(this),this.parentNode=t,this},this.updateWorldMatrix=(t=null)=>{var e,r,i,s,o,a,n,u,h,d,p,f,l,c,m,x,g,y,E,b,v,M,T,B,S,w,P,U,A;return this.shouldUpdate&&this.updateModelMatrix(),t?_(this.worldMatrix,t,this.modelMatrix):I(this.worldMatrix,this.modelMatrix),M=this.normalMatrix,A=this.worldMatrix,e=A[0],r=A[1],i=A[2],s=A[3],o=A[4],a=A[5],n=A[6],u=A[7],T=A[8],S=A[9],P=A[10],h=A[11],d=A[12],p=A[13],f=A[14],l=A[15],(A=(U=e*a-r*o)*(v=P*l-h*f)-(w=e*n-i*o)*(b=S*l-h*p)+(c=e*u-s*o)*(E=S*f-P*p)+(B=r*n-i*a)*(y=T*l-h*d)-(m=r*u-s*a)*(g=T*f-P*d)+(x=i*u-s*n)*(t=T*p-S*d))&&(M[0]=(a*v-n*b+u*E)*(A=1/A),M[1]=(i*b-r*v-s*E)*A,M[2]=(p*x-f*m+l*B)*A,M[3]=(P*m-S*x-h*B)*A,M[4]=(n*y-o*v-u*g)*A,M[5]=(e*v-i*y+s*g)*A,M[6]=(f*c-d*x-l*w)*A,M[7]=(T*x-P*c+h*w)*A,M[8]=(o*b-a*y+u*t)*A,M[9]=(r*y-e*b-s*t)*A,M[10]=(d*m-p*c+l*U)*A,M[11]=(S*c-T*m-h*U)*A,M[12]=(a*g-o*E-n*t)*A,M[13]=(e*E-r*g+i*t)*A,M[14]=(p*w-d*B-f*U)*A,M[15]=(T*B-S*w+P*U)*A),M=this.normalMatrix,T=this.normalMatrix,M===T?(B=T[1],S=T[2],w=T[3],P=T[6],U=T[7],A=T[11],M[1]=T[4],M[2]=T[8],M[3]=T[12],M[4]=B,M[6]=T[9],M[7]=T[13],M[8]=S,M[9]=P,M[11]=T[14],M[12]=w,M[13]=U,M[14]=A):(M[0]=T[0],M[1]=T[4],M[2]=T[8],M[3]=T[12],M[4]=T[1],M[5]=T[5],M[6]=T[9],M[7]=T[13],M[8]=T[2],M[9]=T[6],M[10]=T[10],M[11]=T[14],M[12]=T[3],M[13]=T[7],M[14]=T[11],M[15]=T[15]),this.children.forEach(t=>{t.updateWorldMatrix(this.worldMatrix)}),this},this.traverseGraph=(e,t=this)=>(e(t),this.children.forEach(t=>t.traverseGraph(e)),this)}}class x{constructor(t,e,r,i,s,o){this.left=-1,this.right=1,this.top=1,this.bottom=-1,this.near=.1,this.far=2e3,this.zoom=1,this.position=[0,0,0],this.lookAtPosition=[0,0,0],this.projectionMatrix=n(),this.viewMatrix=n(),this.left=t,this.right=e,this.top=r,this.bottom=i,this.near=s,this.far=o,this.updateProjectionMatrix()}setPosition({x:t=this.position[0],y:e=this.position[1],z:r=this.position[2]}){return this.position=[t,e,r],this}updateViewMatrix(){var t,e,r,i,s,o,a,n,u,h,d,p,f,l;return t=this.viewMatrix,e=this.position,r=this.lookAtPosition,i=x.UP_VECTOR,o=e[0],a=e[1],n=e[2],u=i[0],h=i[1],d=i[2],p=r[0],f=r[1],l=r[2],Math.abs(o-p)<c&&Math.abs(a-f)<c&&Math.abs(n-l)<c?g(t):(s=o-p,e=a-f,i=n-l,p=h*(i*=r=1/Math.hypot(s,e,i))-d*(e*=r),f=d*(s*=r)-u*i,l=u*e-h*s,(r=Math.hypot(p,f,l))?(p*=r=1/r,f*=r,l*=r):l=f=p=0,d=e*l-i*f,u=i*p-s*l,h=s*f-e*p,(r=Math.hypot(d,u,h))?(d*=r=1/r,u*=r,h*=r):h=u=d=0,t[0]=p,t[1]=d,t[2]=s,t[3]=0,t[4]=f,t[5]=u,t[6]=e,t[7]=0,t[8]=l,t[9]=h,t[10]=i,t[11]=0,t[12]=-(p*o+f*a+l*n),t[13]=-(d*o+u*a+h*n),t[14]=-(s*o+e*a+i*n),t[15]=1),this}updateProjectionMatrix(){var t,e,r,i,s,o,a,n,u,h;return t=this.projectionMatrix,e=this.left,r=this.right,i=this.bottom,s=this.top,o=this.near,a=this.far,n=1/(e-r),u=1/(i-s),h=1/(o-a),t[0]=-2*n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*u,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*h,t[11]=0,t[12]=(e+r)*n,t[13]=(s+i)*u,t[14]=(a+o)*h,t[15]=1,this}lookAt(t){return this.lookAtPosition=t,this.updateViewMatrix(),this}}x.UP_VECTOR=[0,1,0];class y extends m{constructor(t,{geometry:e,uniforms:r={},storages:i=[],textures:s=[],samplers:o=[],vertexShaderSource:a,fragmentShaderSource:n,multisample:u={},depthStencil:h={format:"depth24plus",depthWriteEnabled:!0,depthCompare:"less"},targets:d=[{format:"bgra8unorm"}],primitiveType:p=S}){super(),this.renderable=!0,this.uniforms={},e.primitiveType=p,this.device=t,this.geometry=e;let f=0;for(var[l,c]of Object.entries(r)){this.uniforms[l]=Object.assign({byteOffset:f},c);l=w.get(c.type);if(!l)throw new Error("cant find uniform mapping");var[c,l]=l;f+=c*l}const m=f?2:1,x=new M(t),g=new T(t);f&&x.addUniformInputs(r),x.addShaderVars(e.vertexBuffers,a.outputs).addSamplerInputs(o.map(({name:t,wglslSamplerType:e},r)=>({bindIdx:m+r,name:t,type:e}))).addTextureInputs(s.map(({name:t,wglslTextureType:e},r)=>({bindIdx:m+o.length+r,name:t,type:`${e}`}))).addStorages(i.map(({dataStride:t,structDefinition:e,name:r},i)=>({bindIdx:m+o.length+s.length+i,name:r,attributes:e,dataStride:t}))).addHeadSnippet(a.head).addMainFnSnippet(a.main),f&&g.addUniformInputs(r),g.addShaderVars(e.vertexBuffers,n.inputs,n.outputs).addSamplerInputs(o.map(({name:t,wglslSamplerType:e},r)=>({bindIdx:m+r,name:t,type:e}))).addTextureInputs(s.map(({name:t,wglslTextureType:e},r)=>({bindIdx:m+o.length+r,name:t,type:`${e}`}))).addStorages(i.map(({name:t,dataStride:e,structDefinition:r},i)=>({dataStride:e,bindIdx:m+o.length+s.length+i,name:t,attributes:r}))).addHeadSnippet(n.head).addMainFnSnippet(n.main),this.uboBindGroup=new B(t,0);var y,E;this.uboBindGroup.addUBO(64*Float32Array.BYTES_PER_ELEMENT),f&&this.uboBindGroup.addUBO(f);for({value:y,byteOffset:E}of Object.values(this.uniforms))this.uboBindGroup.writeToUBO(1,E,y);o.forEach(t=>this.uboBindGroup.addSampler(t)),s.map(t=>this.uboBindGroup.addTexture(t)),i.forEach(t=>this.uboBindGroup.addStorage(t));const b={layout:this.device.createPipelineLayout({bindGroupLayouts:[this.uboBindGroup.getLayout()]}),vertex:{module:x.shaderModule,entryPoint:v.ENTRY_FUNCTION,buffers:e.getVertexBuffersLayout()},fragment:{module:g.shaderModule,entryPoint:v.ENTRY_FUNCTION,targets:d},primitive:{topology:p,stripIndexFormat:e.stripIndexFormat},multisample:u};h&&(b.depthStencil=h),this.pipeline=t.createRenderPipeline(b),this.uboBindGroup.attachToPipeline(this.pipeline)}setUniform(t,e){t=this.uniforms[t];if(!t)throw new Error("Uniform does not belong to UBO");return this.uboBindGroup.writeToUBO(1,t.byteOffset,e),this}render(t,e){var r;this.updateWorldMatrix(null===(r=this.parentNode)||void 0===r?void 0:r.worldMatrix),this.uboBindGroup.writeToUBO(0,32*Float32Array.BYTES_PER_ELEMENT,this.worldMatrix).writeToUBO(0,48*Float32Array.BYTES_PER_ELEMENT,this.normalMatrix),this.uboBindGroup.writeToUBO(0,0,e.projectionMatrix).writeToUBO(0,16*Float32Array.BYTES_PER_ELEMENT,e.viewMatrix),this.uboBindGroup.bind(t),t.setPipeline(this.pipeline),this.geometry.draw(t)}destroy(){this.uboBindGroup.destroy()}}t(void 0,void 0,void 0,function*(){var t=yield null===(t=navigator.gpu)||void 0===t?void 0:t.requestAdapter();const e=`
    <div id="no-webgpu-wrapper">
      <div id="no-webgpu">
        WebGPU is not supported on this browser. Please try modern Google Chrome (Canary) or Firefox Nightly.
      </div>
    </div>
  `;window.addEventListener("unhandledrejection",t=>{document.body.innerHTML+=e}),window.addEventListener("error",t=>{document.body.innerHTML+=e}),t||(document.body.innerHTML+=e)}),t(void 0,void 0,void 0,function*(){const t=document.getElementById("gpu-c");t.width=innerWidth*devicePixelRatio,t.height=innerHeight*devicePixelRatio,t.style.setProperty("width",`${innerWidth}px`),t.style.setProperty("height",`${innerHeight}px`);const e=yield null===(i=navigator.gpu)||void 0===i?void 0:i.requestAdapter(),o=yield null===e||void 0===e?void 0:e.requestDevice(),a=t.getContext("webgpu");var r=a.getPreferredFormat(e);a.configure({device:o,format:r});const n=new x(0,t.width,t.height,0,.1,3).setPosition({x:0,y:0,z:2}).lookAt([0,0,0]).updateProjectionMatrix().updateViewMatrix();var i=new Float32Array([-240,-240,1,0,0,240,-240,0,1,0,240,240,0,0,1,-240,240,1,1,0]),r=new h(o,0,i,5*Float32Array.BYTES_PER_ELEMENT).addAttribute("position",0,2*Float32Array.BYTES_PER_ELEMENT,"float32x2").addAttribute("color",2*Float32Array.BYTES_PER_ELEMENT,3*Float32Array.BYTES_PER_ELEMENT,"float32x3"),i=new s(o,new Uint16Array([0,1,3,3,1,2])),r=new d(o).addIndexBuffer(i).addVertexBuffer(r);const u=new y(o,{geometry:r,vertexShaderSource:{main:`
        output.Position = transform.projectionMatrix *
                          transform.viewMatrix *
                          transform.modelMatrix *
                          vec4<f32>(input.position, 0.0, 1.0);
                    
        output.color = input.color;
      `},fragmentShaderSource:{main:`
        output.Color = vec4<f32>(input.color.rgb, 1.0);
      `},depthStencil:null,primitiveType:"triangle-list"}).setPosition({x:t.width/2,y:t.height/2,z:0}).updateModelMatrix();requestAnimationFrame(function t(e){requestAnimationFrame(t);const r=o.createCommandEncoder();const i=a.getCurrentTexture().createView();const s=r.beginRenderPass({colorAttachments:[{view:i,loadValue:[.1,.1,.1,1],storeOp:"store"}]});u.render(s,n);s.endPass();o.queue.submit([r.finish()])})})}();
